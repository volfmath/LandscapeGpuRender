// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LandscapeVertexFactory.usf: Landscape vertex factory.
=============================================================================*/

#include "VertexFactoryCommon.ush"

#define VERTEX_FACTORY_MODIFIES_TESSELLATION 1

// Set by FLightMapTexturePolicy
#include "/Engine/Generated/UniformBuffers/PrecomputedLightingBuffer.ush"


Buffer<uint> LandscapeGpuRenderOutputBuffer;

//Test
uint TestLodParameter;
//Test

#if (ES3_1_PROFILE)
/* Offset for UV localization for large UV values. */
float2 TexCoordOffset;
#endif

struct FVertexFactoryInput
{	
	uint InstanceId : SV_InstanceID;
	float2 Position : ATTRIBUTE0;
	//float4 PackedPosition: ATTRIBUTE0; 
};

struct FVertexFactoryInterpolantsVSToPS
{
	float2 LayerTexCoord : TEXCOORD0; // xy == texcoord

#if (ES3_1_PROFILE)
	float2	WeightMapTexCoord		: TEXCOORD1;
	float4	TransformedTexCoord0	: TEXCOORD2;
	float4  TransformedTexCoord1	: TEXCOORD3;
#else
	float4 WeightHeightMapTexCoord : TEXCOORD1;
	float4 TransformedTexCoords : TEXCOORD2;
#endif
#if NEEDS_LIGHTMAP_COORDINATE
	#if (ES3_1_PROFILE)
		float2	LightMapCoordinate[2]	: TEXCOORD4;
		float2	ShadowMapCoordinate		: TEXCOORD6;
	#else
		float4	LightMapCoordinate		: TEXCOORD3;
	#endif
#endif

#if INSTANCED_STEREO
	nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

struct FLandscapeTexCoords
{
	float2 LayerTexCoord : TEXCOORD0; // xy == texcoord

	float2 WeightMapTexCoord;
#if !(ES3_1_PROFILE)
	float2 HeightMapTexCoord;
#endif
#if NEEDS_LIGHTMAP_COORDINATE
	float2	LightMapCoordinate;
#endif
};

struct FVertexFactoryIntermediates
{
	float3 LocalPosition;
	float3 WorldNormal;
};

float3 GetLocalPosition(FVertexFactoryIntermediates Intermediates)
{
	return INVARIANT(Intermediates.LocalPosition);
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	//@StarLight code - BEGIN Add rain depth pass, edit by wanghai
#if RENDER_RAIN_DEPTH
		return INVARIANT(TransformLocalToWorld(GetLocalPosition(Intermediates)));
#else
	return INVARIANT(TransformLocalToTranslatedWorld(GetLocalPosition(Intermediates)));
#endif
	//@StarLight code - END Add rain depth pass, edit by wanghai
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.WorldNormal;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	// Note we still use LocalToWorld. Landscape's transform never changes.
	float3 LocalPosition = GetLocalPosition(Intermediates);
	float3 RotatedPosition = INVARIANT(Primitive.LocalToWorld[0].xyz * LocalPosition.xxx + Primitive.LocalToWorld[1].xyz * LocalPosition.yyy + Primitive.LocalToWorld[2].xyz * LocalPosition.zzz);
	return INVARIANT(float4(RotatedPosition + (Primitive.LocalToWorld[3].xyz + ResolvedView.PrevPreViewTranslation.xyz), 1));
}

/** Calculate the texture coordinates generated by Landscape */
FLandscapeTexCoords GetLandscapeTexCoords(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
//	FLandscapeTexCoords Result;

//	Result.LayerTexCoord.xy = Intermediates.LocalPosition.xy + LandscapeParameters.SubsectionSizeVertsLayerUVPan.zw + Intermediates.InputPosition.zw * LandscapeParameters.SubsectionOffsetParams.ww;

//#if USING_TESSELLATION
//	Result.LayerTexCoord.zw = Intermediates.TessellationFalloff;
//#endif

//	Result.WeightMapTexCoord = Intermediates.LocalPosition.xy * LandscapeParameters.WeightmapUVScaleBias.xy + LandscapeParameters.WeightmapUVScaleBias.zw + Intermediates.InputPosition.zw * LandscapeParameters.SubsectionOffsetParams.zz;

//#if !(ES3_1_PROFILE)
//	Result.HeightMapTexCoord = Intermediates.LocalPosition.xy * LandscapeParameters.HeightmapUVScaleBias.xy + LandscapeParameters.HeightmapUVScaleBias.zw + 0.5 * LandscapeParameters.HeightmapUVScaleBias.xy + Intermediates.InputPosition.zw * LandscapeParameters.SubsectionOffsetParams.xy;
//#endif

//#if NEEDS_LIGHTMAP_COORDINATE
//	Result.LightMapCoordinate = (Intermediates.LocalPosition.xy * LandscapeParameters.LandscapeLightmapScaleBias.xy + LandscapeParameters.LandscapeLightmapScaleBias.wz + Intermediates.InputPosition.zw * LandscapeParameters.LightmapSubsectionOffsetParams.xy);
//#endif
	
//	return Result;
	FLandscapeTexCoords Result;

	Result.LayerTexCoord.xy = float2(0.f, 0.f);
	
	Result.WeightMapTexCoord = float2(0.f, 0.f);

#if NEEDS_LIGHTMAP_COORDINATE
	Result.LightMapCoordinate = float2(0.f, 0.f); 
	/*(Intermediates.LocalPosition.xy * LandscapeParameters.LandscapeLightmapScaleBias.xy + LandscapeParameters.LandscapeLightmapScaleBias.wz + Intermediates.InputPosition.zw * LandscapeParameters.LightmapSubsectionOffsetParams.xy);*/
#endif
	
	return Result;
}

float3x3 CalcTangentBasisFromWorldNormal(float3 Normal)
{
	float3 LocalTangentX = normalize(float3(Normal.z, 0, -Normal.x));
	float3 LocalTangentY = cross(Normal, LocalTangentX);

	float3x3 LocalToTangent = float3x3(LocalTangentX, LocalTangentY, Normal);

	return LocalToTangent;
}

/** Lookup per-pixel tangent basis from heightmap texture */
float3x3 VertexFactoryGetPerPixelTangentBasis(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	float3x3 Result;
#if PIXELSHADER || RAYHITGROUPSHADER || COMPUTESHADER
	//#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4
	//	float4 SampleValue = Texture2DSample(LandscapeParameters.NormalmapTexture, LandscapeParameters.NormalmapTextureSampler, Interpolants.WeightHeightMapTexCoord.zw);
	//#else
	//	float4 SampleValue = Texture2DSample(LandscapeParameters.NormalmapTexture, LandscapeParameters.NormalmapTextureSampler, Interpolants.WeightMapTexCoord);
	//#endif
	
	float4 SampleValue = float4(0.f, 0.f, 0.f, 0.f);
	float2 SampleNormal = float2(SampleValue.b, SampleValue.a) * float2(2.0,2.0) - float2(1.0,1.0);
	float3 WorldNormal = float3( SampleNormal, sqrt(max(1.0-dot(SampleNormal,SampleNormal),0.0)) );
	Result = CalcTangentBasisFromWorldNormal(WorldNormal);
	#endif
	return Result;
}

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
	// GetMaterialPixelParameters is responsible for fully initializing the result
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

#if NEEDS_LIGHTMAP_COORDINATE
#if (ES3_1_PROFILE)
		// Not supported in pixel shader
		float2 LightmapUVs = float2(0, 0);
#else
		float2 LightmapUVs = Interpolants.LightMapCoordinate.xy;
#endif
#else
	float2 LightmapUVs = float2(0, 0);
#endif

#if NUM_MATERIAL_TEXCOORDS     // XY layer
	Result.TexCoords[0] = Interpolants.LayerTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 1 // VS calcualted TexCoord 1, default is XZ layer
#if (ES3_1_PROFILE)
		Result.TexCoords[1] = Interpolants.TransformedTexCoord0.xy;
#else
		Result.TexCoords[1] = Interpolants.TransformedTexCoords.xy;
#endif
#if NUM_MATERIAL_TEXCOORDS > 2 // VS calcualted TexCoord 2, default is YZ layer
#if (ES3_1_PROFILE)
		Result.TexCoords[2] = Interpolants.TransformedTexCoord1.xy;
#else
		Result.TexCoords[2] = Interpolants.TransformedTexCoords.zw;
#endif
#if NUM_MATERIAL_TEXCOORDS > 3 // Weightmap
#if (ES3_1_PROFILE)
		Result.TexCoords[3] = Interpolants.WeightMapTexCoord;
#else
		Result.TexCoords[3] = Interpolants.WeightHeightMapTexCoord.xy;
#endif
#if NUM_MATERIAL_TEXCOORDS > 4 // Lightmap
#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[4] = LightmapUVs;
#else
		Result.TexCoords[4] = float2(0,0);
#endif
#if NUM_MATERIAL_TEXCOORDS > 5 // Height map
#if (ES3_1_PROFILE)
		Result.TexCoords[5] = float2(0,0); // Height map UV not supported
#else
		Result.TexCoords[5] = Interpolants.WeightHeightMapTexCoord.zw;
#endif
#if NUM_MATERIAL_TEXCOORDS > 6
	for (uint CoordinateIndex = 6; CoordinateIndex < NUM_MATERIAL_TEXCOORDS; CoordinateIndex++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
	}
#endif // 6
#endif // 5
#endif // 4
#endif // 3
#endif // 2
#endif // 1
#endif // 0

	// Calculate LocalToTangent directly from normal map texture.
	float3x3 TangentToLocal = VertexFactoryGetPerPixelTangentBasis(Interpolants);
	Result.TangentToWorld = TangentToLocal; /*mul(TangentToLocal, (float3x3) LandscapeParameters.LocalToWorldNoScaling);*/
	Result.UnMirrored = 1;

	Result.VertexColor = 1;

#if LIGHTMAP_UV_ACCESS
	Result.LightmapUVs = LightmapUVs;
#endif

#if (ES3_1_PROFILE) && PIXELSHADER
	//Result.LayerWeights.xy = Texture2DSample(LandscapeParameters.NormalmapTexture, LandscapeParameters.NormalmapTextureSampler, Interpolants.WeightMapTexCoord).rg;
	//Result.LayerWeights.z = saturate(LandscapeParameters.BlendableLayerMask.z - dot(Result.LayerWeights.xy, LandscapeParameters.BlendableLayerMask.xy));
	Result.LayerWeights.xyz = float3(0.f, 0.f, 0.f);
	Result.LayerWeights.w = 0; // Total weight need to be 1
#endif

	Result.TwoSidedSign = 1;
	return Result;
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, float3x3 TangentToLocal)
{
	FMaterialVertexParameters Result = (FMaterialVertexParameters) 0;
	Result.WorldPosition = WorldPosition;
	Result.VertexColor = float4(1, 1, 1, 1);
	Result.TangentToWorld = TangentToLocal; /*mul(TangentToLocal, (float3x3) LandscapeParameters.LocalToWorldNoScaling);*/
	Result.PreSkinnedPosition = Intermediates.LocalPosition.xyz;
	Result.PreSkinnedNormal = TangentToLocal[2].xyz;

	// Assumes no instancing and landscape's transform never change
	Result.PrevFrameLocalToWorld = Primitive.LocalToWorld;

	FLandscapeTexCoords LandscapeTexCoords = GetLandscapeTexCoords(Input, Intermediates);

#if NUM_MATERIAL_TEXCOORDS_VERTEX     // XY layer
	Result.TexCoords[0] = LandscapeTexCoords.LayerTexCoord.xy;
#if (ES3_1_PROFILE)
		Result.TexCoordOffset = TexCoordOffset;
#endif
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 1 // XZ layer
	Result.TexCoords[1] = float2(LandscapeTexCoords.LayerTexCoord.x, Intermediates.LocalPosition.z);
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 2 // YZ layer
	Result.TexCoords[2] = float2(LandscapeTexCoords.LayerTexCoord.y, Intermediates.LocalPosition.z);
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 3 // Weightmap
	Result.TexCoords[3] = LandscapeTexCoords.WeightMapTexCoord;
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 4 // Lightmap
#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[4] = LandscapeTexCoords.LightMapCoordinate.xy;
#else
		Result.TexCoords[4] = float2(0,0);
#endif
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 5 // Height map
#if (ES3_1_PROFILE)
		Result.TexCoords[5] = float2(0,0); // Height map UV not supported
#else
		Result.TexCoords[5] = LandscapeTexCoords.HeightMapTexCoord;
#endif
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 6
	UNROLL
	for (uint CoordinateIndex = 6; CoordinateIndex < NUM_MATERIAL_TEXCOORDS_VERTEX; CoordinateIndex++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
	}
#endif // 6
#endif // 5
#endif // 4
#endif // 3
#endif // 2
#endif // 1
#endif // 0

	return Result;
}

#if NEEDS_LIGHTMAP_COORDINATE
void GetLightMapCoordinates(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 LightmapUV0, out float2 LightmapUV1, out uint LightmapDataIndex)
{
#if (ES3_1_PROFILE)
	LightmapUV0 = Interpolants.LightMapCoordinate[0].xy;
	LightmapUV1 = Interpolants.LightMapCoordinate[1].xy;
#else
	LightmapUV0 = Interpolants.LightMapCoordinate.xy * float2( 1, 0.5 );
	LightmapUV1 = LightmapUV0 + float2( 0, 0.5 );
#endif
	LightmapDataIndex = 0;
}

void GetShadowMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 ShadowMapCoordinate, out uint LightmapDataIndex)
{
#if (ES3_1_PROFILE)
	ShadowMapCoordinate = Interpolants.ShadowMapCoordinate.xy;
#else
	ShadowMapCoordinate = Interpolants.LightMapCoordinate.zw;
#endif
	LightmapDataIndex = 0;
}
#endif

//void EdgeFunc()
//{

//	bool DownAdjust = LodDifference.x > 0 && (ClampPosition.y == UniformLodSize.y || (ClampPosition.y == NonUniformLodSize.y && EdgeCluster.y));
//	bool LeftAdjust = LodDifference.y > 0 && ClampPosition.x == 0;
//	bool TopAdjust = LodDifference.z > 0 && ClampPosition.y == 0;
//	bool RightAdjust = LodDifference.w > 0 && (ClampPosition.x == UniformLodSize.x || (ClampPosition.x == NonUniformLodSize.x && EdgeCluster.x));

//	if (DownAdjust)
//	{
//		if (EdgeCluster.x)
//		{
//			ClampPosition.x = max(float(((ClmapPositionUint.x + 1) >> LodDifference.x) - 1), 0.f);
//			NonUniformLodSize.x = float(AdjustQuadSize.x >> LodDifference.x) - 1.f;
//		}
//		else
//		{
//			ClampPosition.x = float(ClmapPositionUint.x >> LodDifference.x);
//			AdjustScale.x = AdjustScale.x * float(1 << LodDifference.x);
//		}
//	}
	
//	if (LeftAdjust)
//	{
//		if (EdgeCluster.y)
//		{
//			ClampPosition.y = max(float(((ClmapPositionUint.y + 1) >> LodDifference.y) - 1), 0.f);
//			NonUniformLodSize.y = float(AdjustQuadSize.y >> LodDifference.y) - 1.f;
//		}
//		else
//		{
//			ClampPosition.y = float(ClmapPositionUint.y >> LodDifference.y);
//			AdjustScale.y = AdjustScale.y * float(1 << LodDifference.y);
//		}
//	}
	
//	if (TopAdjust)
//	{
//		if (EdgeCluster.x)
//		{
//			ClampPosition.x = max(float(((ClmapPositionUint.x + 1) >> LodDifference.z) - 1), 0.f);
//			NonUniformLodSize.x = float(AdjustQuadSize.x >> LodDifference.z) - 1.f;
//		}
//		else
//		{
//			ClampPosition.x = float(ClmapPositionUint.x >> LodDifference.z);
//			AdjustScale.x = AdjustScale.x * float(1 << LodDifference.z);
//		}
//	}
	
//	if (RightAdjust)
//	{
//		if (EdgeCluster.y)
//		{
//			ClampPosition.y = max(float(((ClmapPositionUint.y + 1) >> LodDifference.w) - 1), 0.f);
//			NonUniformLodSize.y = float(AdjustQuadSize.y >> LodDifference.w) - 1.f;
//		}
//		else
//		{
//			ClampPosition.y = float(ClmapPositionUint.y >> LodDifference.w);
//			AdjustScale.y = AdjustScale.y * float(1 << LodDifference.w);
//		}
//	}
//}


FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates;
	
	//UnPackData
	uint PackData = LandscapeGpuRenderOutputBuffer[Input.InstanceId + TestLodParameter * 16];
	uint3 UnPackData_0 = (PackData >> uint3(0, 8, 28)) & uint3(0xff, 0xff, 0x7);
	uint4 LodDataNeighbor = (PackData >> uint4(16, 19, 22, 25)) & 0x7;
	uint2 ClusterIndex = UnPackData_0.xy;
	uint SelfLod = UnPackData_0.z;

	float2 SelfLodScale = float2(1 << SelfLod, 1 << SelfLod);
	uint2 SelfAdjustQuadSize = uint2(LandscapeGpuRenderUniformBuffer.QuadSizeParameter.xx) >> SelfLod;
	float2 SelfUniformLodSize = float2(SelfAdjustQuadSize);
	float2 SelfNonUniformLodSize = float2(SelfAdjustQuadSize) - 1.f;
	
	uint2 ClusterOffset = ClusterIndex.xy & (LandscapeGpuRenderUniformBuffer.NumClusterPerSection - 1);
	bool2 EdgeCluster = ClusterOffset == LandscapeGpuRenderUniformBuffer.NumClusterPerSection - 1;
	float2 ClampPosition = EdgeCluster ? min(Input.Position, SelfNonUniformLodSize) : Input.Position; //float2(EdgeCluster.x ? min(Input.Position.x, NonUniformLodSize.x) : Input.Position.x, EdgeCluster.y ? min(Input.Position.y, NonUniformLodSize.y) : Input.Position.y);
	int2 ClmapPositionUint = int2(ClampPosition);
	int4 LodDifference = int4(LodDataNeighbor) - int4(SelfLod, SelfLod, SelfLod, SelfLod);
	
	bool4 LodVarible = LodDifference > 0 && bool4
	(
		ClampPosition.y == SelfUniformLodSize.y || (ClampPosition.y == SelfNonUniformLodSize.y && EdgeCluster.y),
		ClampPosition.x == 0,
		ClampPosition.y == 0,
		ClampPosition.x == SelfUniformLodSize.x || (ClampPosition.x == SelfNonUniformLodSize.x && EdgeCluster.x)
	);
	
	float4 NoUniformClampPosition = max(float4(((ClmapPositionUint.xyxy + int4(1, 1, 1, 1)) >> LodDifference) - int4(1, 1, 1, 1)), 0.f);
	float4 NouniformLodSizeSIMD = float4(uint4(SelfAdjustQuadSize.xyxy) >> LodDifference) - 1.f;
	float4 UniformClampPosition = float4(ClmapPositionUint.xyxy >> LodDifference);
	float4 AdjustLodScaleSIMD = SelfLodScale.xyxy * float4(1 << LodDifference);
	
	//Optimize the code, see EdgeFunc function for details
	ClampPosition = LodVarible.xw ? (EdgeCluster.xy ? NoUniformClampPosition.xw : UniformClampPosition.xw) : ClampPosition;
	ClampPosition = LodVarible.zy ? (EdgeCluster.xy ? NoUniformClampPosition.zy : UniformClampPosition.zy) : ClampPosition;
	//Regardless of whether direct calculation is used or not, save to NonUniformLodSize and AdjustLodScale
	float2 NonUniformLodSize = LodVarible.xw ? NouniformLodSizeSIMD.xw : (LodVarible.zy ? NouniformLodSizeSIMD.zy : SelfNonUniformLodSize);
	float2 AdjustLodScale = LodVarible.xw ? AdjustLodScaleSIMD.xw : (LodVarible.zy ? AdjustLodScaleSIMD.zy : SelfLodScale);
	ClampPosition = EdgeCluster ? ClampPosition / NonUniformLodSize * (LandscapeGpuRenderUniformBuffer.QuadSizeParameter.x - 1.f) : ClampPosition * AdjustLodScale;
	
	uint2 SectionBlock = ClusterIndex.xy / LandscapeGpuRenderUniformBuffer.NumClusterPerSection;
	float2 ClusterPositionSection = ClusterOffset * LandscapeGpuRenderUniformBuffer.QuadSizeParameter.xx;
	float2 ClusterPositionGlobal = SectionBlock * LandscapeGpuRenderUniformBuffer.QuadSizeParameter.yy + ClusterPositionSection;
	
	Intermediates.LocalPosition = float3(ClampPosition + ClusterPositionGlobal, 0.f);
	Intermediates.WorldNormal = float3( 0.0, 0.0, 1.0 );
	
	return Intermediates;
}


/**
* Get the 3x3 tangent basis vectors for this vertex factory
* this vertex factory will calculate the binormal on-the-fly
*
* @param Input - vertex input stream structure
* @return 3x3 matrix
*/
float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	float3x3 Result = CalcTangentBasisFromWorldNormal(Intermediates.WorldNormal);
	return Result;
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
	return InWorldPosition;
}

float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
	return TranslatedWorldPosition;
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants;

	Interpolants = (FVertexFactoryInterpolantsVSToPS) 0;
	FLandscapeTexCoords LandscapeTexCoords = GetLandscapeTexCoords(Input, Intermediates);

#if (ES3_1_PROFILE)
	Interpolants.LayerTexCoord	= LandscapeTexCoords.LayerTexCoord;
	Interpolants.WeightMapTexCoord	= LandscapeTexCoords.WeightMapTexCoord; 
#if NUM_MATERIAL_TEXCOORDS
		float2 CustomizedUVs[NUM_MATERIAL_TEXCOORDS];
		GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);

		Interpolants.LayerTexCoord.xy = CustomizedUVs[0];
#if NUM_MATERIAL_TEXCOORDS > 1
			Interpolants.TransformedTexCoord0.xy	= CustomizedUVs[1];
#if NUM_MATERIAL_TEXCOORDS > 2
				Interpolants.TransformedTexCoord1.xy	= CustomizedUVs[2];
#endif // 2
			// ignore 4th CustomizedUV because of weightmap UV
#endif // 1
#endif //NUM_MATERIAL_TEXCOORDS
#else
	Interpolants.LayerTexCoord = LandscapeTexCoords.LayerTexCoord;
	Interpolants.WeightHeightMapTexCoord.xy = LandscapeTexCoords.WeightMapTexCoord;
	Interpolants.WeightHeightMapTexCoord.zw = LandscapeTexCoords.HeightMapTexCoord;
#if NUM_MATERIAL_TEXCOORDS
		float2 CustomizedUVs[NUM_MATERIAL_TEXCOORDS];
		GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);

		Interpolants.LayerTexCoord.xy = CustomizedUVs[0];
		Interpolants.TransformedTexCoords = 0;

#if NUM_MATERIAL_TEXCOORDS > 1
			Interpolants.TransformedTexCoords.xy = CustomizedUVs[1];
#if NUM_MATERIAL_TEXCOORDS > 2
				Interpolants.TransformedTexCoords.zw = CustomizedUVs[2];
#endif // 2
#endif // 1

#endif // NUM_MATERIAL_TEXCOORDS
#endif // (ES3_1_PROFILE)

#if NEEDS_LIGHTMAP_COORDINATE
	#if (ES3_1_PROFILE)
		Interpolants.LightMapCoordinate[0].xy = LandscapeTexCoords.LightMapCoordinate * PrecomputedLightingBuffer.LightMapCoordinateScaleBias.xy + PrecomputedLightingBuffer.LightMapCoordinateScaleBias.zw;
		Interpolants.LightMapCoordinate[0].y *= 0.5;
		Interpolants.LightMapCoordinate[1].xy = Interpolants.LightMapCoordinate[0].xy;
		Interpolants.LightMapCoordinate[1].y += 0.5;
		#if STATICLIGHTING_TEXTUREMASK
			Interpolants.ShadowMapCoordinate.xy	= LandscapeTexCoords.LightMapCoordinate.xy * PrecomputedLightingBuffer.ShadowMapCoordinateScaleBias.xy + PrecomputedLightingBuffer.ShadowMapCoordinateScaleBias.zw;
		#else
			Interpolants.ShadowMapCoordinate.xy = 0;
		#endif
		#else
		Interpolants.LightMapCoordinate.xy		= LandscapeTexCoords.LightMapCoordinate.xy * PrecomputedLightingBuffer.LightMapCoordinateScaleBias.xy + PrecomputedLightingBuffer.LightMapCoordinateScaleBias.zw;
		#if STATICLIGHTING_TEXTUREMASK
			Interpolants.LightMapCoordinate.zw	= LandscapeTexCoords.LightMapCoordinate.xy * PrecomputedLightingBuffer.ShadowMapCoordinateScaleBias.xy + PrecomputedLightingBuffer.ShadowMapCoordinateScaleBias.zw;
		#else
			Interpolants.LightMapCoordinate.zw = 0;
		#endif
	#endif
#endif

#if INSTANCED_STEREO
	Interpolants.EyeIndex = 0;
#endif
	
	return Interpolants;
}

#if NUM_VF_PACKED_INTERPOLANTS > 0
void VertexFactoryPackInterpolants(inout FVertexFactoryInterpolantsVSToPS Interpolants, float4 PackedInterpolants[NUM_VF_PACKED_INTERPOLANTS])
{
	Interpolants.TransformedTexCoord0.zw = PackedInterpolants[0].xy;
	Interpolants.TransformedTexCoord1.zw = PackedInterpolants[0].zw;
}

void VertexFactoryUnpackInterpolants(FVertexFactoryInterpolantsVSToPS Interpolants, out float4 PackedInterpolants[NUM_VF_PACKED_INTERPOLANTS])
{
	PackedInterpolants[0].xy = Interpolants.TransformedTexCoord0.zw;
	PackedInterpolants[0].zw = Interpolants.TransformedTexCoord1.zw;
#if NUM_VF_PACKED_INTERPOLANTS > 1
	UNROLL
	for (int i = 1; i < NUM_VF_PACKED_INTERPOLANTS; ++i)
	{
		PackedInterpolants[i] = 0;
	}
#endif
}
#endif // NUM_VF_PACKED_INTERPOLANTS > 0

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}
