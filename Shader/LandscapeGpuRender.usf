#include "Common.ush"

#define GROUP_TILE_SIZE     64
#define GROUP_TILE_SIZE_1	8
#define DRAWCOMMAND_SIZE	5

//[Input]
/* Layout
float3 ViewOriginPosition;
float4 ProjMatrixParameters; (ProjMatrix.M[0][0], ProjMatrix.M[1][1], ProjMatrix.M[2][3], ClusterSqureSizePerComponent)
float4 LODSettingsComponent; (LastLODScreenSizeSquared, LOD1ScreenSizeSquared, LODOnePlusDistributionScalarSquared, LastLODIndex)
*/
float4 LodCSParameters[3];
Buffer<float4> ComponentsOriginAndRadiusSRV;

//[Output]
RWBuffer<uint> ClusterLodBufferUAV;
RWBuffer<uint> ClusterLodCountUAV_0;

float ComputeBoundsScreenRadiusSquared(float4 OriginAndRadius)
{
	// ignore perspective foreshortening for orthographic projections
	// const float DistSqr = FVector::DistSquared(BoundsOrigin, ViewOrigin) * ProjMatrix.M[2][3];
	float3 ViewOriginPosition = LodCSParameters[0].xyz;
	float3 ProjMatrixParameters = LodCSParameters[1].xyz;
	const float DistSqr = dot(ViewOriginPosition - OriginAndRadius.xyz, ViewOriginPosition - OriginAndRadius.xyz) * ProjMatrixParameters.z;

	// Get projection multiple accounting for view scaling.
	const float ScreenMultiple = max(0.5f * ProjMatrixParameters.x, 0.5f * ProjMatrixParameters.y);

	// Calculate screen-space projected radius
	return Square(ScreenMultiple * OriginAndRadius.w) / max(1.0f, DistSqr);
}

uint GetLODFromScreenSize(float InScreenSizeSquared, const uint LastLodIndex)
{
	//LODDistanceFactor Don't consider LODScale for now
	//float ScreenSizeSquared = InScreenSizeSquared / InViewLODScale;
	float ScreenSizeSquared = InScreenSizeSquared;
	float4 LODSettings = LodCSParameters[2];
	
	uint CurLod = ScreenSizeSquared <= LODSettings.x ? LastLodIndex
					: ScreenSizeSquared > LODSettings.y ? 0
						: (1 + log2(LODSettings.y / ScreenSizeSquared) / log2(LODSettings.z));
	
	return CurLod;
}

[numthreads(GROUP_TILE_SIZE, 1, 1)]
void ClusterComputeLODCS(uint DispatchThreadId : SV_DispatchThreadID)
{
	float BoundsScreenRadiusSquared = ComputeBoundsScreenRadiusSquared(ComponentsOriginAndRadiusSRV[DispatchThreadId]);
	uint LastLodIndex = (uint) LodCSParameters[2].w;
	uint Lod = GetLODFromScreenSize(BoundsScreenRadiusSquared, LastLodIndex);
	uint ClusterSqureSizePerComponent = (uint)LodCSParameters[1].w;
	uint StartClusterIndex = DispatchThreadId * ClusterSqureSizePerComponent;
	
	LOOP
	for (uint ClusterIndex = 0; ClusterIndex < ClusterSqureSizePerComponent; ++ClusterIndex)
	{
		ClusterLodBufferUAV[StartClusterIndex + ClusterIndex] = Lod;
	}
	
	//Clear EntityCountBuffer
	if (DispatchThreadId <= LastLodIndex)
	{
		ClusterLodCountUAV_0[DispatchThreadId] = 0;
	}
}

//[Input]
struct ClusterInputData
{
	float3 BoundCenter;
	float Pad_0;
	float3 BoundExtent;
	float Pad_1;
};

float4 ViewFrustumPermutedPlanes[8];
uint4 LandscapeParameters; //(LandscapeParameters.xy, LandscapeParameters.z, 0)
//uint LandscapeParameters.z;
//uint2 LandscapeComponentSize;
Buffer<uint> ClusterLodBufferSRV;
StructuredBuffer<ClusterInputData> ClusterInputData_SRV;

//[Output]
RWBuffer<uint2> ClusterOutBufferUAV;
RWBuffer<uint> ClusterLodCountUAV;


bool IntersectBox8Plane(in float3 Center, in float3 Extent, out bool InsideNearPlane)
{
	float4 DistX_0 = Center.xxxx * ViewFrustumPermutedPlanes[0];
	float4 DistY_0 = Center.yyyy * ViewFrustumPermutedPlanes[1] + DistX_0;
	float4 DistZ_0 = Center.zzzz * ViewFrustumPermutedPlanes[2] + DistY_0;
	float4 Distance_0 = DistZ_0 - ViewFrustumPermutedPlanes[3];
    
	float4 PushX_0 = Extent.xxxx * abs(ViewFrustumPermutedPlanes[0]);
	float4 PushY_0 = Extent.yyyy * abs(ViewFrustumPermutedPlanes[1]) + PushX_0;
	float4 PushOut_0 = Extent.zzzz * abs(ViewFrustumPermutedPlanes[2]) + PushY_0;

	if (any(Distance_0 > PushOut_0))
	{
		return false;
	}

	InsideNearPlane = Distance_0.x < -PushOut_0.x;
    
	float4 DistX_1 = Center.xxxx * ViewFrustumPermutedPlanes[4];
	float4 DistY_1 = Center.yyyy * ViewFrustumPermutedPlanes[5] + DistX_1;
	float4 DistZ_1 = Center.zzzz * ViewFrustumPermutedPlanes[6] + DistY_1;
	float4 Distance_1 = DistZ_1 - ViewFrustumPermutedPlanes[7];
    
	float4 PushX_1 = Extent.xxxx * abs(ViewFrustumPermutedPlanes[4]);
	float4 PushY_1 = Extent.yyyy * abs(ViewFrustumPermutedPlanes[5]) + PushX_1;
	float4 PushOut_1 = Extent.zzzz * abs(ViewFrustumPermutedPlanes[6]) + PushY_1;
    
	if (any(Distance_1 > PushOut_1))
	{
		return false;
	}
    
	return true;
}

uint GetLinearIndexByClusterIndex(in int2 ClusterIndex)
{
	uint2 ClampSize = clamp(ClusterIndex, int2(0, 0), int2(LandscapeParameters.xy * LandscapeParameters.z) - int2(1, 1));
	uint ClusterSqureSizePerComponent = LandscapeParameters.z * LandscapeParameters.z;
	uint2 ClusterOffset = ClampSize & (LandscapeParameters.z - 1);
	uint2 ComponentOffset = ClampSize / LandscapeParameters.z;
	uint offset_1 = ComponentOffset.y * ClusterSqureSizePerComponent * LandscapeParameters.xy.x + ComponentOffset.x * ClusterSqureSizePerComponent;
	uint offset_2 = ClusterOffset.x + ClusterOffset.y * LandscapeParameters.z;
	return offset_1 + offset_2;
}

uint2 GetLinearIndexByClusterIndexBatch(in uint4 ClusterIndex)
{
	uint4 ClampSize = clamp((int4) ClusterIndex, int4(0, 0, 0, 0), int4(LandscapeParameters.xyxy * LandscapeParameters.z) - int4(1, 1, 1, 1));
	uint4 ClusterOffset = ClampSize & (LandscapeParameters.z - 1);
	uint4 ComponentOffset = ClampSize / LandscapeParameters.z;
	uint ClusterSqureSizePerComponent = LandscapeParameters.z * LandscapeParameters.z;
	uint2 offset_1 = ComponentOffset.yw * ClusterSqureSizePerComponent * LandscapeParameters.xy.x + ComponentOffset.xz * ClusterSqureSizePerComponent;
	uint2 offset_2 = ClusterOffset.xz + ClusterOffset.yw * LandscapeParameters.z;
	return offset_1 + offset_2;
}

[numthreads(GROUP_TILE_SIZE_1, GROUP_TILE_SIZE_1, 1)]
void LandscapeGpuCullingCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	//保证一个Wrap访问的内存连续, Cache friend
	uint CenterLinearIndex = GetLinearIndexByClusterIndex(DispatchThreadId);
	ClusterInputData RenderData = ClusterInputData_SRV[CenterLinearIndex];
	uint ClusterLod = ClusterLodBufferSRV[CenterLinearIndex];
	bool InsideNearPlane;
	bool bIsFrustumVisible = IntersectBox8Plane(RenderData.BoundCenter, RenderData.BoundExtent, InsideNearPlane);
	uint PackOutputData = 0;
	uint CurrentLodCount = 0xFFFFFFFF;
	
	BRANCH
	if (!bIsFrustumVisible)
	{
		ClusterOutBufferUAV[CenterLinearIndex] = uint2(PackOutputData, CurrentLodCount);
		return;
	}
	
	//打包对应数据到输出数据中
	uint DownLod = ClusterLodBufferSRV[GetLinearIndexByClusterIndex(int2(0, 1) + (int2) DispatchThreadId)];
	uint LeftLod = ClusterLodBufferSRV[GetLinearIndexByClusterIndex(int2(-1, 0) + (int2) DispatchThreadId)];
	uint TopLod = ClusterLodBufferSRV[GetLinearIndexByClusterIndex(int2(0, -1) + (int2) DispatchThreadId)];
	uint RightLod = ClusterLodBufferSRV[GetLinearIndexByClusterIndex(int2(1, 0) + (int2) DispatchThreadId)];
	
	PackOutputData = PackOutputData | (DispatchThreadId.x & 0xFF);
	PackOutputData = PackOutputData | ((DispatchThreadId.y << 8) & 0xFF00); // There may be an error in the ARM register?
	PackOutputData = PackOutputData | ((DownLod << 16) & 0x70000);
	PackOutputData = PackOutputData | ((LeftLod << 19) & 0x380000);
	PackOutputData = PackOutputData | ((TopLod << 22) & 0x1C00000);
	PackOutputData = PackOutputData | ((RightLod << 25) & 0xE000000);
	PackOutputData = PackOutputData | ((ClusterLod << 28) & 0x70000000);
		
	//统计LOD数量并写入PackData和自身Index到Buffer中
	InterlockedAdd(ClusterLodCountUAV[ClusterLod], 1, CurrentLodCount);
	ClusterOutBufferUAV[CenterLinearIndex] = uint2(PackOutputData, CurrentLodCount);
}

//[Input]
Buffer<uint2> ClusterOutBufferSRV;
Buffer<uint> ClusterLodCountSRV;

//[Output]
RWBuffer<uint> OrderClusterOutBufferUAV;
RWBuffer<uint> DrawCommandBufferUAV;

//#todo: IndirectDispatch
[numthreads(GROUP_TILE_SIZE, 1,  1)]
void LandscapeGpuSortedCS(uint DispatchThreadId : SV_DispatchThreadID)
{
	//顺带写入
	if (DispatchThreadId < 5)
	{
		DrawCommandBufferUAV[DispatchThreadId * DRAWCOMMAND_SIZE + 1] = ClusterLodCountSRV[DispatchThreadId];
	}
	
	uint2 PackDataAndReadIndex = ClusterOutBufferSRV[DispatchThreadId];
	if (PackDataAndReadIndex.y != 0xFFFFFFFF)
	{
		uint CurrentClusterLod = ((PackDataAndReadIndex.x >> 28) & 0x7);
		uint CurrentClusterLodStartIndex = 0;
		for (uint LodIndex = 0; LodIndex < CurrentClusterLod; ++LodIndex)
		{
			CurrentClusterLodStartIndex += ClusterLodCountSRV[LodIndex];
		}
		//Write Value
		OrderClusterOutBufferUAV[PackDataAndReadIndex.y + CurrentClusterLodStartIndex] = PackDataAndReadIndex.x;
	}
}